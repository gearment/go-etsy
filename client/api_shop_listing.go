/*
Etsy Open API v3

<div class=\"wt-text-body-01\"><p class=\"wt-pt-xs-2 wt-pb-xs-2\">Etsy's Open API provides a simple RESTful interface for various Etsy.com features. The API endpoints are meant to replace Etsy's Open API v2, which is scheduled to end service in 2022.</p><p class=\"wt-pb-xs-2\">All of the endpoints are callable and the majority of the API endpoints are now in a beta phase. This means we do not expect to make any breaking changes before our general release. A handful of endpoints are currently interface stubs (labeled “Feedback Only”) and returns a \"501 Not Implemented\" response code when called.</p><p class=\"wt-pb-xs-2\">If you'd like to report an issue or provide feedback on the API design, <a target=\"_blank\" class=\"wt-text-link wt-p-xs-0\" href=\"https://github.com/etsy/open-api/discussions\">please add an issue in Github</a>.</p></div>&copy; 2021-2024 Etsy, Inc. All Rights Reserved. Use of this code is subject to Etsy's <a class='wt-text-link wt-p-xs-0' target='_blank' href='https://www.etsy.com/legal/api'>API Developer Terms of Use</a>.

API version: 3.0.0
Contact: developers@etsy.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package goEtsy

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

type ShopListingAPI interface {

	/*
			CreateDraftListing Method for CreateDraftListing

			<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notificationPrimary wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

		Creates a physical draft [listing](/documentation/reference#tag/ShopListing) product in a shop on the Etsy channel.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param shopId The unique positive non-zero numeric ID for an Etsy Shop.
			@return ShopListingAPICreateDraftListingRequest
	*/
	CreateDraftListing(ctx context.Context, shopId int64) ShopListingAPICreateDraftListingRequest

	// CreateDraftListingExecute executes the request
	//  @return ShopListing
	CreateDraftListingExecute(r ShopListingAPICreateDraftListingRequest) (*ShopListing, *http.Response, error)

	/*
			DeleteListing Method for DeleteListing

			<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notificationPrimary wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

		Open API V3 endpoint to delete a ShopListing. A ShopListing can be deleted only if the state is one of the following:  SOLD_OUT, DRAFT, EXPIRED, INACTIVE, ACTIVE and is_available or ACTIVE and has seller flags:  SUPRESSED (frozen), VACATION, CUSTOM_SHOPS (pattern), SELL_ON_FACEBOOK

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param listingId The numeric ID for the [listing](/documentation/reference#tag/ShopListing) associated to this transaction.
			@return ShopListingAPIDeleteListingRequest
	*/
	DeleteListing(ctx context.Context, listingId int64) ShopListingAPIDeleteListingRequest

	// DeleteListingExecute executes the request
	DeleteListingExecute(r ShopListingAPIDeleteListingRequest) (*http.Response, error)

	/*
			DeleteListingProperty Method for DeleteListingProperty

			<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notificationPrimary wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

		Deletes a property for a Listing.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param shopId The unique positive non-zero numeric ID for an Etsy Shop.
			@param listingId The numeric ID for the [listing](/documentation/reference#tag/ShopListing) associated to this transaction.
			@param propertyId The unique ID of an Etsy [listing property](/documentation/reference#operation/getListingProperties).
			@return ShopListingAPIDeleteListingPropertyRequest
	*/
	DeleteListingProperty(ctx context.Context, shopId int64, listingId int64, propertyId int64) ShopListingAPIDeleteListingPropertyRequest

	// DeleteListingPropertyExecute executes the request
	DeleteListingPropertyExecute(r ShopListingAPIDeleteListingPropertyRequest) (*http.Response, error)

	/*
			FindAllActiveListingsByShop Method for FindAllActiveListingsByShop

			<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notificationPrimary wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

		Retrieves a list of all active listings on Etsy in a specific shop, paginated by listing creation date.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param shopId The unique positive non-zero numeric ID for an Etsy Shop.
			@return ShopListingAPIFindAllActiveListingsByShopRequest
	*/
	FindAllActiveListingsByShop(ctx context.Context, shopId int64) ShopListingAPIFindAllActiveListingsByShopRequest

	// FindAllActiveListingsByShopExecute executes the request
	//  @return ShopListings
	FindAllActiveListingsByShopExecute(r ShopListingAPIFindAllActiveListingsByShopRequest) (*ShopListings, *http.Response, error)

	/*
			FindAllListingsActive Method for FindAllListingsActive

			<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notificationPrimary wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

		A list of all active listings on Etsy paginated by their creation date. Without sort_order listings will be returned newest-first by default.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return ShopListingAPIFindAllListingsActiveRequest
	*/
	FindAllListingsActive(ctx context.Context) ShopListingAPIFindAllListingsActiveRequest

	// FindAllListingsActiveExecute executes the request
	//  @return ShopListings
	FindAllListingsActiveExecute(r ShopListingAPIFindAllListingsActiveRequest) (*ShopListings, *http.Response, error)

	/*
			GetFeaturedListingsByShop Method for GetFeaturedListingsByShop

			<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notificationPrimary wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

		Retrieves Listings associated to a Shop that are featured.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param shopId The unique positive non-zero numeric ID for an Etsy Shop.
			@return ShopListingAPIGetFeaturedListingsByShopRequest
	*/
	GetFeaturedListingsByShop(ctx context.Context, shopId int64) ShopListingAPIGetFeaturedListingsByShopRequest

	// GetFeaturedListingsByShopExecute executes the request
	//  @return ShopListings
	GetFeaturedListingsByShopExecute(r ShopListingAPIGetFeaturedListingsByShopRequest) (*ShopListings, *http.Response, error)

	/*
			GetListing Method for GetListing

			<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notificationPrimary wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

		Retrieves a listing record by listing ID.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param listingId The numeric ID for the [listing](/documentation/reference#tag/ShopListing) associated to this transaction.
			@return ShopListingAPIGetListingRequest
	*/
	GetListing(ctx context.Context, listingId int64) ShopListingAPIGetListingRequest

	// GetListingExecute executes the request
	//  @return ShopListingWithAssociations
	GetListingExecute(r ShopListingAPIGetListingRequest) (*ShopListingWithAssociations, *http.Response, error)

	/*
			GetListingProperties Method for GetListingProperties

			<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notificationPrimary wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

		Get a listing's properties

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param shopId The unique positive non-zero numeric ID for an Etsy Shop.
			@param listingId The numeric ID for the [listing](/documentation/reference#tag/ShopListing) associated to this transaction.
			@return ShopListingAPIGetListingPropertiesRequest
	*/
	GetListingProperties(ctx context.Context, shopId int64, listingId int64) ShopListingAPIGetListingPropertiesRequest

	// GetListingPropertiesExecute executes the request
	//  @return ListingPropertyValues
	GetListingPropertiesExecute(r ShopListingAPIGetListingPropertiesRequest) (*ListingPropertyValues, *http.Response, error)

	/*
			GetListingProperty Method for GetListingProperty

			<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notificationTertiary wt-mr-xs-2"> Feedback only </span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Give feedback</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">Development for this endpoint is in progress. It will only return a 501 response.</p></div>

		Retrieves a listing's property

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param listingId The numeric ID for the [listing](/documentation/reference#tag/ShopListing) associated to this transaction.
			@param propertyId The unique ID of an Etsy [listing property](/documentation/reference#operation/getListingProperties).
			@return ShopListingAPIGetListingPropertyRequest
	*/
	GetListingProperty(ctx context.Context, listingId int64, propertyId int64) ShopListingAPIGetListingPropertyRequest

	// GetListingPropertyExecute executes the request
	//  @return ListingPropertyValue
	GetListingPropertyExecute(r ShopListingAPIGetListingPropertyRequest) (*ListingPropertyValue, *http.Response, error)

	/*
			GetListingsByListingIds Method for GetListingsByListingIds

			<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notificationPrimary wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

		Allows to query multiple listing ids at once. Limit 100 ids maximum per query.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@return ShopListingAPIGetListingsByListingIdsRequest
	*/
	GetListingsByListingIds(ctx context.Context) ShopListingAPIGetListingsByListingIdsRequest

	// GetListingsByListingIdsExecute executes the request
	//  @return ShopListingsWithAssociations
	GetListingsByListingIdsExecute(r ShopListingAPIGetListingsByListingIdsRequest) (*ShopListingsWithAssociations, *http.Response, error)

	/*
			GetListingsByShop Method for GetListingsByShop

			<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notificationPrimary wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

		Endpoint to list Listings that belong to a Shop. Listings can be filtered using the 'state' param.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param shopId The unique positive non-zero numeric ID for an Etsy Shop.
			@return ShopListingAPIGetListingsByShopRequest
	*/
	GetListingsByShop(ctx context.Context, shopId int64) ShopListingAPIGetListingsByShopRequest

	// GetListingsByShopExecute executes the request
	//  @return ShopListingsWithAssociations
	GetListingsByShopExecute(r ShopListingAPIGetListingsByShopRequest) (*ShopListingsWithAssociations, *http.Response, error)

	/*
			GetListingsByShopReceipt Method for GetListingsByShopReceipt

			<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notificationPrimary wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

		Gets all listings associated with a receipt.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param receiptId The numeric ID for the [receipt](/documentation/reference#tag/Shop-Receipt) associated to this transaction.
			@param shopId The unique positive non-zero numeric ID for an Etsy Shop.
			@return ShopListingAPIGetListingsByShopReceiptRequest
	*/
	GetListingsByShopReceipt(ctx context.Context, receiptId int64, shopId int64) ShopListingAPIGetListingsByShopReceiptRequest

	// GetListingsByShopReceiptExecute executes the request
	//  @return ShopListings
	GetListingsByShopReceiptExecute(r ShopListingAPIGetListingsByShopReceiptRequest) (*ShopListings, *http.Response, error)

	/*
			GetListingsByShopReturnPolicy Method for GetListingsByShopReturnPolicy

			<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notificationPrimary wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

		Gets all listings associated with a Return Policy.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param returnPolicyId The numeric ID of the [Return Policy](/documentation/reference#operation/getShopReturnPolicies).
			@param shopId The unique positive non-zero numeric ID for an Etsy Shop.
			@return ShopListingAPIGetListingsByShopReturnPolicyRequest
	*/
	GetListingsByShopReturnPolicy(ctx context.Context, returnPolicyId int64, shopId int64) ShopListingAPIGetListingsByShopReturnPolicyRequest

	// GetListingsByShopReturnPolicyExecute executes the request
	//  @return ShopListings
	GetListingsByShopReturnPolicyExecute(r ShopListingAPIGetListingsByShopReturnPolicyRequest) (*ShopListings, *http.Response, error)

	/*
			GetListingsByShopSectionId Method for GetListingsByShopSectionId

			<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notificationPrimary wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

		Retrieves all the listings from the section of a specific shop.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param shopId The unique positive non-zero numeric ID for an Etsy Shop.
			@return ShopListingAPIGetListingsByShopSectionIdRequest
	*/
	GetListingsByShopSectionId(ctx context.Context, shopId int64) ShopListingAPIGetListingsByShopSectionIdRequest

	// GetListingsByShopSectionIdExecute executes the request
	//  @return ShopListings
	GetListingsByShopSectionIdExecute(r ShopListingAPIGetListingsByShopSectionIdRequest) (*ShopListings, *http.Response, error)

	/*
			UpdateListing Method for UpdateListing

			<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notificationPrimary wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

		Updates a listing, identified by a listing ID, for a specific shop identified by a shop ID. Note that this is a PATCH method type. When activating, or manually renewing a physical listing, the shipping profile referenced by the `shipping_profile_id`, and all of its fields, along with its entries and upgrades must be complete and valid. If the shipping profile is not complete and valid, we will throw an exception with an error message that guides the request sender to update whatever data is bad.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param shopId The unique positive non-zero numeric ID for an Etsy Shop.
			@param listingId The numeric ID for the [listing](/documentation/reference#tag/ShopListing) associated to this transaction.
			@return ShopListingAPIUpdateListingRequest
	*/
	UpdateListing(ctx context.Context, shopId int64, listingId int64) ShopListingAPIUpdateListingRequest

	// UpdateListingExecute executes the request
	//  @return ShopListing
	UpdateListingExecute(r ShopListingAPIUpdateListingRequest) (*ShopListing, *http.Response, error)

	/*
			UpdateListingDeprecated Method for UpdateListingDeprecated

			<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notificationPrimary wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

		Updates a listing, identified by a listing ID, for a specific shop identified by a shop ID. This endpoint will be removed in the near future in favor of `updateListing` PATCH version.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param shopId The unique positive non-zero numeric ID for an Etsy Shop.
			@param listingId The numeric ID for the [listing](/documentation/reference#tag/ShopListing) associated to this transaction.
			@return ShopListingAPIUpdateListingDeprecatedRequest
	*/
	UpdateListingDeprecated(ctx context.Context, shopId int64, listingId int64) ShopListingAPIUpdateListingDeprecatedRequest

	// UpdateListingDeprecatedExecute executes the request
	//  @return ShopListing
	UpdateListingDeprecatedExecute(r ShopListingAPIUpdateListingDeprecatedRequest) (*ShopListing, *http.Response, error)

	/*
			UpdateListingProperty Method for UpdateListingProperty

			<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notificationPrimary wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

		Updates or populates the properties list defining product offerings for a listing. Each offering requires both a `value` and a `value_id` that are valid for a `scale_id` assigned to the listing or that you assign to the listing with this request.

			@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
			@param shopId The unique positive non-zero numeric ID for an Etsy Shop.
			@param listingId The numeric ID for the [listing](/documentation/reference#tag/ShopListing) associated to this transaction.
			@param propertyId The unique ID of an Etsy [listing property](/documentation/reference#operation/getListingProperties).
			@return ShopListingAPIUpdateListingPropertyRequest
	*/
	UpdateListingProperty(ctx context.Context, shopId int64, listingId int64, propertyId int64) ShopListingAPIUpdateListingPropertyRequest

	// UpdateListingPropertyExecute executes the request
	//  @return ListingPropertyValue
	UpdateListingPropertyExecute(r ShopListingAPIUpdateListingPropertyRequest) (*ListingPropertyValue, *http.Response, error)
}

// ShopListingAPIService ShopListingAPI service
type ShopListingAPIService service

type ShopListingAPICreateDraftListingRequest struct {
	ctx                         context.Context
	ApiService                  ShopListingAPI
	shopId                      int64
	quantity                    *int64
	title                       *string
	description                 *string
	price                       *float32
	whoMade                     *CreateDraftListingRequestWhoMade
	whenMade                    *CreateDraftListingRequestWhenMade
	taxonomyId                  *int64
	shippingProfileId           *int64
	returnPolicyId              *int64
	materials                   *[]string
	shopSectionId               *int64
	processingMin               *int64
	processingMax               *int64
	tags                        *[]string
	styles                      *[]string
	itemWeight                  *float32
	itemLength                  *float32
	itemWidth                   *float32
	itemHeight                  *float32
	itemWeightUnit              *CreateDraftListingRequestItemWeightUnit
	itemDimensionsUnit          *CreateDraftListingRequestItemDimensionsUnit
	isPersonalizable            *bool
	personalizationIsRequired   *bool
	personalizationCharCountMax *int64
	personalizationInstructions *string
	productionPartnerIds        *[]int64
	imageIds                    *[]int64
	isSupply                    *bool
	isCustomizable              *bool
	shouldAutoRenew             *bool
	isTaxable                   *bool
	type_                       *CreateDraftListingRequestType
}

// The positive non-zero number of products available for purchase in the listing. Note: The listing quantity is the sum of available offering quantities. You can request the quantities for individual offerings from the ListingInventory resource using the [getListingInventory](/documentation/reference#operation/getListingInventory) endpoint.
func (r ShopListingAPICreateDraftListingRequest) Quantity(quantity int64) ShopListingAPICreateDraftListingRequest {
	r.quantity = &quantity
	return r
}

// The listing&#39;s title string. When creating or updating a listing, valid title strings contain only letters, numbers, punctuation marks, mathematical symbols, whitespace characters, ™, ©, and ®. (regex: /[^\\\\p{L}\\\\p{Nd}\\\\p{P}\\\\p{Sm}\\\\p{Zs}™©®]/u) You can only use the %, :, &amp; and + characters once each.
func (r ShopListingAPICreateDraftListingRequest) Title(title string) ShopListingAPICreateDraftListingRequest {
	r.title = &title
	return r
}

// A description string of the product for sale in the listing.
func (r ShopListingAPICreateDraftListingRequest) Description(description string) ShopListingAPICreateDraftListingRequest {
	r.description = &description
	return r
}

// The positive non-zero price of the product. (Sold product listings are private) Note: The price is the minimum possible price. The [&#x60;getListingInventory&#x60;](/documentation/reference/#operation/getListingInventory) method requests exact prices for available offerings.
func (r ShopListingAPICreateDraftListingRequest) Price(price float32) ShopListingAPICreateDraftListingRequest {
	r.price = &price
	return r
}

func (r ShopListingAPICreateDraftListingRequest) WhoMade(whoMade CreateDraftListingRequestWhoMade) ShopListingAPICreateDraftListingRequest {
	r.whoMade = &whoMade
	return r
}

func (r ShopListingAPICreateDraftListingRequest) WhenMade(whenMade CreateDraftListingRequestWhenMade) ShopListingAPICreateDraftListingRequest {
	r.whenMade = &whenMade
	return r
}

// The numerical taxonomy ID of the listing. See [SellerTaxonomy](/documentation/reference#tag/SellerTaxonomy) and [BuyerTaxonomy](/documentation/reference#tag/BuyerTaxonomy) for more information.
func (r ShopListingAPICreateDraftListingRequest) TaxonomyId(taxonomyId int64) ShopListingAPICreateDraftListingRequest {
	r.taxonomyId = &taxonomyId
	return r
}

// The numeric ID of the [shipping profile](/documentation/reference#operation/getShopShippingProfile) associated with the listing. Required when listing type is &#x60;physical&#x60;.
func (r ShopListingAPICreateDraftListingRequest) ShippingProfileId(shippingProfileId int64) ShopListingAPICreateDraftListingRequest {
	r.shippingProfileId = &shippingProfileId
	return r
}

// The numeric ID of the [Return Policy](/documentation/reference#operation/getShopReturnPolicies).
func (r ShopListingAPICreateDraftListingRequest) ReturnPolicyId(returnPolicyId int64) ShopListingAPICreateDraftListingRequest {
	r.returnPolicyId = &returnPolicyId
	return r
}

// A list of material strings for materials used in the product. Valid materials strings contain only letters, numbers, and whitespace characters. (regex: /[^\\\\p{L}\\\\p{Nd}\\\\p{Zs}]/u) Default value is null.
func (r ShopListingAPICreateDraftListingRequest) Materials(materials []string) ShopListingAPICreateDraftListingRequest {
	r.materials = &materials
	return r
}

// The numeric ID of the [shop section](/documentation/reference#tag/Shop-Section) for this listing. Default value is null.
func (r ShopListingAPICreateDraftListingRequest) ShopSectionId(shopSectionId int64) ShopListingAPICreateDraftListingRequest {
	r.shopSectionId = &shopSectionId
	return r
}

// The minimum number of days required to process this listing. Default value is null.
func (r ShopListingAPICreateDraftListingRequest) ProcessingMin(processingMin int64) ShopListingAPICreateDraftListingRequest {
	r.processingMin = &processingMin
	return r
}

// The maximum number of days required to process this listing. Default value is null.
func (r ShopListingAPICreateDraftListingRequest) ProcessingMax(processingMax int64) ShopListingAPICreateDraftListingRequest {
	r.processingMax = &processingMax
	return r
}

// A comma-separated list of tag strings for the listing. When creating or updating a listing, valid tag strings contain only letters, numbers, whitespace characters, -, &#39;, ™, ©, and ®. (regex: /[^\\\\p{L}\\\\p{Nd}\\\\p{Zs}\\\\-&#39;™©®]/u) Default value is null.
func (r ShopListingAPICreateDraftListingRequest) Tags(tags []string) ShopListingAPICreateDraftListingRequest {
	r.tags = &tags
	return r
}

// An array of style strings for this listing, each of which is free-form text string such as \\\&quot;Formal\\\&quot;, or \\\&quot;Steampunk\\\&quot;. When creating or updating a listing, the listing may have up to two styles. Valid style strings contain only letters, numbers, and whitespace characters. (regex: /[^\\\\p{L}\\\\p{Nd}\\\\p{Zs}]/u) Default value is null.
func (r ShopListingAPICreateDraftListingRequest) Styles(styles []string) ShopListingAPICreateDraftListingRequest {
	r.styles = &styles
	return r
}

// The numeric weight of the product measured in units set in &#39;item_weight_unit&#39;. Default value is null. If set, the value must be greater than 0.
func (r ShopListingAPICreateDraftListingRequest) ItemWeight(itemWeight float32) ShopListingAPICreateDraftListingRequest {
	r.itemWeight = &itemWeight
	return r
}

// The numeric length of the product measured in units set in &#39;item_dimensions_unit&#39;. Default value is null. If set, the value must be greater than 0.
func (r ShopListingAPICreateDraftListingRequest) ItemLength(itemLength float32) ShopListingAPICreateDraftListingRequest {
	r.itemLength = &itemLength
	return r
}

// The numeric width of the product measured in units set in &#39;item_dimensions_unit&#39;. Default value is null. If set, the value must be greater than 0.
func (r ShopListingAPICreateDraftListingRequest) ItemWidth(itemWidth float32) ShopListingAPICreateDraftListingRequest {
	r.itemWidth = &itemWidth
	return r
}

// The numeric height of the product measured in units set in &#39;item_dimensions_unit&#39;. Default value is null. If set, the value must be greater than 0.
func (r ShopListingAPICreateDraftListingRequest) ItemHeight(itemHeight float32) ShopListingAPICreateDraftListingRequest {
	r.itemHeight = &itemHeight
	return r
}

func (r ShopListingAPICreateDraftListingRequest) ItemWeightUnit(itemWeightUnit CreateDraftListingRequestItemWeightUnit) ShopListingAPICreateDraftListingRequest {
	r.itemWeightUnit = &itemWeightUnit
	return r
}

func (r ShopListingAPICreateDraftListingRequest) ItemDimensionsUnit(itemDimensionsUnit CreateDraftListingRequestItemDimensionsUnit) ShopListingAPICreateDraftListingRequest {
	r.itemDimensionsUnit = &itemDimensionsUnit
	return r
}

// When true, this listing is personalizable. The default value is null.
func (r ShopListingAPICreateDraftListingRequest) IsPersonalizable(isPersonalizable bool) ShopListingAPICreateDraftListingRequest {
	r.isPersonalizable = &isPersonalizable
	return r
}

// When true, this listing requires personalization. The default value is null. Will only change if is_personalizable is &#39;true&#39;.
func (r ShopListingAPICreateDraftListingRequest) PersonalizationIsRequired(personalizationIsRequired bool) ShopListingAPICreateDraftListingRequest {
	r.personalizationIsRequired = &personalizationIsRequired
	return r
}

// This is an integer value representing the maximum length for the personalization message entered by the buyer. Will only change if is_personalizable is &#39;true&#39;.
func (r ShopListingAPICreateDraftListingRequest) PersonalizationCharCountMax(personalizationCharCountMax int64) ShopListingAPICreateDraftListingRequest {
	r.personalizationCharCountMax = &personalizationCharCountMax
	return r
}

// A string representing instructions for the buyer to enter the personalization. Will only change if is_personalizable is &#39;true&#39;.
func (r ShopListingAPICreateDraftListingRequest) PersonalizationInstructions(personalizationInstructions string) ShopListingAPICreateDraftListingRequest {
	r.personalizationInstructions = &personalizationInstructions
	return r
}

// An array of unique IDs of production partner ids.
func (r ShopListingAPICreateDraftListingRequest) ProductionPartnerIds(productionPartnerIds []int64) ShopListingAPICreateDraftListingRequest {
	r.productionPartnerIds = &productionPartnerIds
	return r
}

// An array of numeric image IDs of the images in a listing, which can include up to 10 images.
func (r ShopListingAPICreateDraftListingRequest) ImageIds(imageIds []int64) ShopListingAPICreateDraftListingRequest {
	r.imageIds = &imageIds
	return r
}

// When true, tags the listing as a supply product, else indicates that it&#39;s a finished product. Helps buyers locate the listing under the Supplies heading. Requires &#39;who_made&#39; and &#39;when_made&#39;.
func (r ShopListingAPICreateDraftListingRequest) IsSupply(isSupply bool) ShopListingAPICreateDraftListingRequest {
	r.isSupply = &isSupply
	return r
}

// When true, a buyer may contact the seller for a customized order. The default value is true when a shop accepts custom orders. Does not apply to shops that do not accept custom orders.
func (r ShopListingAPICreateDraftListingRequest) IsCustomizable(isCustomizable bool) ShopListingAPICreateDraftListingRequest {
	r.isCustomizable = &isCustomizable
	return r
}

// When true, renews a listing for four months upon expiration.
func (r ShopListingAPICreateDraftListingRequest) ShouldAutoRenew(shouldAutoRenew bool) ShopListingAPICreateDraftListingRequest {
	r.shouldAutoRenew = &shouldAutoRenew
	return r
}

// When true, applicable [shop](/documentation/reference#tag/Shop) tax rates apply to this listing at checkout.
func (r ShopListingAPICreateDraftListingRequest) IsTaxable(isTaxable bool) ShopListingAPICreateDraftListingRequest {
	r.isTaxable = &isTaxable
	return r
}

func (r ShopListingAPICreateDraftListingRequest) Type_(type_ CreateDraftListingRequestType) ShopListingAPICreateDraftListingRequest {
	r.type_ = &type_
	return r
}

func (r ShopListingAPICreateDraftListingRequest) Execute() (*ShopListing, *http.Response, error) {
	return r.ApiService.CreateDraftListingExecute(r)
}

/*
CreateDraftListing Method for CreateDraftListing

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notificationPrimary wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Creates a physical draft [listing](/documentation/reference#tag/ShopListing) product in a shop on the Etsy channel.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shopId The unique positive non-zero numeric ID for an Etsy Shop.
	@return ShopListingAPICreateDraftListingRequest
*/
func (a *ShopListingAPIService) CreateDraftListing(ctx context.Context, shopId int64) ShopListingAPICreateDraftListingRequest {
	return ShopListingAPICreateDraftListingRequest{
		ApiService: a,
		ctx:        ctx,
		shopId:     shopId,
	}
}

// Execute executes the request
//
//	@return ShopListing
func (a *ShopListingAPIService) CreateDraftListingExecute(r ShopListingAPICreateDraftListingRequest) (*ShopListing, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ShopListing
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopListingAPIService.CreateDraftListing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/shops/{shop_id}/listings"
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId < 1 {
		return localVarReturnValue, nil, reportError("shopId must be greater than 1")
	}
	if r.quantity == nil {
		return localVarReturnValue, nil, reportError("quantity is required and must be specified")
	}
	if r.title == nil {
		return localVarReturnValue, nil, reportError("title is required and must be specified")
	}
	if r.description == nil {
		return localVarReturnValue, nil, reportError("description is required and must be specified")
	}
	if r.price == nil {
		return localVarReturnValue, nil, reportError("price is required and must be specified")
	}
	if r.whoMade == nil {
		return localVarReturnValue, nil, reportError("whoMade is required and must be specified")
	}
	if r.whenMade == nil {
		return localVarReturnValue, nil, reportError("whenMade is required and must be specified")
	}
	if r.taxonomyId == nil {
		return localVarReturnValue, nil, reportError("taxonomyId is required and must be specified")
	}
	if *r.taxonomyId < 1 {
		return localVarReturnValue, nil, reportError("taxonomyId must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "quantity", r.quantity, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "title", r.title, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "description", r.description, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "price", r.price, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "who_made", r.whoMade, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "when_made", r.whenMade, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "taxonomy_id", r.taxonomyId, "", "")
	if r.shippingProfileId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "shipping_profile_id", r.shippingProfileId, "", "")
	}
	if r.returnPolicyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "return_policy_id", r.returnPolicyId, "", "")
	}
	if r.materials != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "materials", r.materials, "", "csv")
	}
	if r.shopSectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "shop_section_id", r.shopSectionId, "", "")
	}
	if r.processingMin != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "processing_min", r.processingMin, "", "")
	}
	if r.processingMax != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "processing_max", r.processingMax, "", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "tags", r.tags, "", "csv")
	}
	if r.styles != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "styles", r.styles, "", "csv")
	}
	if r.itemWeight != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "item_weight", r.itemWeight, "", "")
	}
	if r.itemLength != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "item_length", r.itemLength, "", "")
	}
	if r.itemWidth != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "item_width", r.itemWidth, "", "")
	}
	if r.itemHeight != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "item_height", r.itemHeight, "", "")
	}
	if r.itemWeightUnit != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "item_weight_unit", r.itemWeightUnit, "", "")
	}
	if r.itemDimensionsUnit != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "item_dimensions_unit", r.itemDimensionsUnit, "", "")
	}
	if r.isPersonalizable != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_personalizable", r.isPersonalizable, "", "")
	}
	if r.personalizationIsRequired != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "personalization_is_required", r.personalizationIsRequired, "", "")
	}
	if r.personalizationCharCountMax != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "personalization_char_count_max", r.personalizationCharCountMax, "", "")
	}
	if r.personalizationInstructions != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "personalization_instructions", r.personalizationInstructions, "", "")
	}
	if r.productionPartnerIds != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "production_partner_ids", r.productionPartnerIds, "", "csv")
	}
	if r.imageIds != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "image_ids", r.imageIds, "", "csv")
	}
	if r.isSupply != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_supply", r.isSupply, "", "")
	}
	if r.isCustomizable != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_customizable", r.isCustomizable, "", "")
	}
	if r.shouldAutoRenew != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "should_auto_renew", r.shouldAutoRenew, "", "")
	}
	if r.isTaxable != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_taxable", r.isTaxable, "", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-api-key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ShopListingAPIDeleteListingRequest struct {
	ctx        context.Context
	ApiService ShopListingAPI
	listingId  int64
}

func (r ShopListingAPIDeleteListingRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteListingExecute(r)
}

/*
DeleteListing Method for DeleteListing

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notificationPrimary wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Open API V3 endpoint to delete a ShopListing. A ShopListing can be deleted only if the state is one of the following:  SOLD_OUT, DRAFT, EXPIRED, INACTIVE, ACTIVE and is_available or ACTIVE and has seller flags:  SUPRESSED (frozen), VACATION, CUSTOM_SHOPS (pattern), SELL_ON_FACEBOOK

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listingId The numeric ID for the [listing](/documentation/reference#tag/ShopListing) associated to this transaction.
	@return ShopListingAPIDeleteListingRequest
*/
func (a *ShopListingAPIService) DeleteListing(ctx context.Context, listingId int64) ShopListingAPIDeleteListingRequest {
	return ShopListingAPIDeleteListingRequest{
		ApiService: a,
		ctx:        ctx,
		listingId:  listingId,
	}
}

// Execute executes the request
func (a *ShopListingAPIService) DeleteListingExecute(r ShopListingAPIDeleteListingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopListingAPIService.DeleteListing")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/listings/{listing_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"listing_id"+"}", url.PathEscape(parameterValueToString(r.listingId, "listingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.listingId < 1 {
		return nil, reportError("listingId must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-api-key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ShopListingAPIDeleteListingPropertyRequest struct {
	ctx        context.Context
	ApiService ShopListingAPI
	shopId     int64
	listingId  int64
	propertyId int64
}

func (r ShopListingAPIDeleteListingPropertyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteListingPropertyExecute(r)
}

/*
DeleteListingProperty Method for DeleteListingProperty

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notificationPrimary wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Deletes a property for a Listing.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shopId The unique positive non-zero numeric ID for an Etsy Shop.
	@param listingId The numeric ID for the [listing](/documentation/reference#tag/ShopListing) associated to this transaction.
	@param propertyId The unique ID of an Etsy [listing property](/documentation/reference#operation/getListingProperties).
	@return ShopListingAPIDeleteListingPropertyRequest
*/
func (a *ShopListingAPIService) DeleteListingProperty(ctx context.Context, shopId int64, listingId int64, propertyId int64) ShopListingAPIDeleteListingPropertyRequest {
	return ShopListingAPIDeleteListingPropertyRequest{
		ApiService: a,
		ctx:        ctx,
		shopId:     shopId,
		listingId:  listingId,
		propertyId: propertyId,
	}
}

// Execute executes the request
func (a *ShopListingAPIService) DeleteListingPropertyExecute(r ShopListingAPIDeleteListingPropertyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopListingAPIService.DeleteListingProperty")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/shops/{shop_id}/listings/{listing_id}/properties/{property_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listing_id"+"}", url.PathEscape(parameterValueToString(r.listingId, "listingId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property_id"+"}", url.PathEscape(parameterValueToString(r.propertyId, "propertyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId < 1 {
		return nil, reportError("shopId must be greater than 1")
	}
	if r.listingId < 1 {
		return nil, reportError("listingId must be greater than 1")
	}
	if r.propertyId < 1 {
		return nil, reportError("propertyId must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-api-key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ShopListingAPIFindAllActiveListingsByShopRequest struct {
	ctx        context.Context
	ApiService ShopListingAPI
	shopId     int64
	limit      *int64
	sortOn     *GetListingsByShopSortOnParameter
	sortOrder  *GetListingsByShopSortOrderParameter
	offset     *int64
	keywords   *string
}

// The maximum number of results to return.
func (r ShopListingAPIFindAllActiveListingsByShopRequest) Limit(limit int64) ShopListingAPIFindAllActiveListingsByShopRequest {
	r.limit = &limit
	return r
}

// The value to sort a search result of listings on. NOTES: a) &#x60;sort_on&#x60; only works when combined with one of the search options (keywords, region, etc.). b) when using &#x60;score&#x60; the returned results will always be in _descending_ order, regardless of the &#x60;sort_order&#x60; parameter.
func (r ShopListingAPIFindAllActiveListingsByShopRequest) SortOn(sortOn GetListingsByShopSortOnParameter) ShopListingAPIFindAllActiveListingsByShopRequest {
	r.sortOn = &sortOn
	return r
}

// The ascending(up) or descending(down) order to sort listings by. NOTE: sort_order only works when combined with one of the search options (keywords, region, etc.).
func (r ShopListingAPIFindAllActiveListingsByShopRequest) SortOrder(sortOrder GetListingsByShopSortOrderParameter) ShopListingAPIFindAllActiveListingsByShopRequest {
	r.sortOrder = &sortOrder
	return r
}

// The number of records to skip before selecting the first result.
func (r ShopListingAPIFindAllActiveListingsByShopRequest) Offset(offset int64) ShopListingAPIFindAllActiveListingsByShopRequest {
	r.offset = &offset
	return r
}

// Search term or phrase that must appear in all results.
func (r ShopListingAPIFindAllActiveListingsByShopRequest) Keywords(keywords string) ShopListingAPIFindAllActiveListingsByShopRequest {
	r.keywords = &keywords
	return r
}

func (r ShopListingAPIFindAllActiveListingsByShopRequest) Execute() (*ShopListings, *http.Response, error) {
	return r.ApiService.FindAllActiveListingsByShopExecute(r)
}

/*
FindAllActiveListingsByShop Method for FindAllActiveListingsByShop

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notificationPrimary wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Retrieves a list of all active listings on Etsy in a specific shop, paginated by listing creation date.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shopId The unique positive non-zero numeric ID for an Etsy Shop.
	@return ShopListingAPIFindAllActiveListingsByShopRequest
*/
func (a *ShopListingAPIService) FindAllActiveListingsByShop(ctx context.Context, shopId int64) ShopListingAPIFindAllActiveListingsByShopRequest {
	return ShopListingAPIFindAllActiveListingsByShopRequest{
		ApiService: a,
		ctx:        ctx,
		shopId:     shopId,
	}
}

// Execute executes the request
//
//	@return ShopListings
func (a *ShopListingAPIService) FindAllActiveListingsByShopExecute(r ShopListingAPIFindAllActiveListingsByShopRequest) (*ShopListings, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ShopListings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopListingAPIService.FindAllActiveListingsByShop")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/shops/{shop_id}/listings/active"
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId < 1 {
		return localVarReturnValue, nil, reportError("shopId must be greater than 1")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int64 = 25
		r.limit = &defaultValue
	}
	if r.sortOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_on", r.sortOn, "form", "")
	} else {
		var defaultValue GetListingsByShopSortOnParameter = "created"
		r.sortOn = &defaultValue
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_order", r.sortOrder, "form", "")
	} else {
		var defaultValue GetListingsByShopSortOrderParameter = "desc"
		r.sortOrder = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int64 = 0
		r.offset = &defaultValue
	}
	if r.keywords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keywords", r.keywords, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-api-key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ShopListingAPIFindAllListingsActiveRequest struct {
	ctx          context.Context
	ApiService   ShopListingAPI
	limit        *int64
	offset       *int64
	keywords     *string
	sortOn       *GetListingsByShopSortOnParameter
	sortOrder    *GetListingsByShopSortOrderParameter
	minPrice     *float32
	maxPrice     *float32
	taxonomyId   *int64
	shopLocation *string
}

// The maximum number of results to return.
func (r ShopListingAPIFindAllListingsActiveRequest) Limit(limit int64) ShopListingAPIFindAllListingsActiveRequest {
	r.limit = &limit
	return r
}

// The number of records to skip before selecting the first result.
func (r ShopListingAPIFindAllListingsActiveRequest) Offset(offset int64) ShopListingAPIFindAllListingsActiveRequest {
	r.offset = &offset
	return r
}

// Search term or phrase that must appear in all results.
func (r ShopListingAPIFindAllListingsActiveRequest) Keywords(keywords string) ShopListingAPIFindAllListingsActiveRequest {
	r.keywords = &keywords
	return r
}

// The value to sort a search result of listings on. NOTES: a) &#x60;sort_on&#x60; only works when combined with one of the search options (keywords, region, etc.). b) when using &#x60;score&#x60; the returned results will always be in _descending_ order, regardless of the &#x60;sort_order&#x60; parameter.
func (r ShopListingAPIFindAllListingsActiveRequest) SortOn(sortOn GetListingsByShopSortOnParameter) ShopListingAPIFindAllListingsActiveRequest {
	r.sortOn = &sortOn
	return r
}

// The ascending(up) or descending(down) order to sort listings by. NOTE: sort_order only works when combined with one of the search options (keywords, region, etc.).
func (r ShopListingAPIFindAllListingsActiveRequest) SortOrder(sortOrder GetListingsByShopSortOrderParameter) ShopListingAPIFindAllListingsActiveRequest {
	r.sortOrder = &sortOrder
	return r
}

// The minimum price of listings to be returned by a search result.
func (r ShopListingAPIFindAllListingsActiveRequest) MinPrice(minPrice float32) ShopListingAPIFindAllListingsActiveRequest {
	r.minPrice = &minPrice
	return r
}

// The maximum price of listings to be returned by a search result.
func (r ShopListingAPIFindAllListingsActiveRequest) MaxPrice(maxPrice float32) ShopListingAPIFindAllListingsActiveRequest {
	r.maxPrice = &maxPrice
	return r
}

// The numerical taxonomy ID of the listing. See [SellerTaxonomy](/documentation/reference#tag/SellerTaxonomy) and [BuyerTaxonomy](/documentation/reference#tag/BuyerTaxonomy) for more information.
func (r ShopListingAPIFindAllListingsActiveRequest) TaxonomyId(taxonomyId int64) ShopListingAPIFindAllListingsActiveRequest {
	r.taxonomyId = &taxonomyId
	return r
}

// Filters by shop location. If location cannot be parsed, Etsy responds with an error.
func (r ShopListingAPIFindAllListingsActiveRequest) ShopLocation(shopLocation string) ShopListingAPIFindAllListingsActiveRequest {
	r.shopLocation = &shopLocation
	return r
}

func (r ShopListingAPIFindAllListingsActiveRequest) Execute() (*ShopListings, *http.Response, error) {
	return r.ApiService.FindAllListingsActiveExecute(r)
}

/*
FindAllListingsActive Method for FindAllListingsActive

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notificationPrimary wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

A list of all active listings on Etsy paginated by their creation date. Without sort_order listings will be returned newest-first by default.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ShopListingAPIFindAllListingsActiveRequest
*/
func (a *ShopListingAPIService) FindAllListingsActive(ctx context.Context) ShopListingAPIFindAllListingsActiveRequest {
	return ShopListingAPIFindAllListingsActiveRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ShopListings
func (a *ShopListingAPIService) FindAllListingsActiveExecute(r ShopListingAPIFindAllListingsActiveRequest) (*ShopListings, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ShopListings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopListingAPIService.FindAllListingsActive")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/listings/active"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int64 = 25
		r.limit = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int64 = 0
		r.offset = &defaultValue
	}
	if r.keywords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keywords", r.keywords, "form", "")
	}
	if r.sortOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_on", r.sortOn, "form", "")
	} else {
		var defaultValue GetListingsByShopSortOnParameter = "created"
		r.sortOn = &defaultValue
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_order", r.sortOrder, "form", "")
	} else {
		var defaultValue GetListingsByShopSortOrderParameter = "desc"
		r.sortOrder = &defaultValue
	}
	if r.minPrice != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_price", r.minPrice, "form", "")
	}
	if r.maxPrice != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_price", r.maxPrice, "form", "")
	}
	if r.taxonomyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "taxonomy_id", r.taxonomyId, "form", "")
	}
	if r.shopLocation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "shop_location", r.shopLocation, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-api-key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ShopListingAPIGetFeaturedListingsByShopRequest struct {
	ctx        context.Context
	ApiService ShopListingAPI
	shopId     int64
	limit      *int64
	offset     *int64
}

// The maximum number of results to return.
func (r ShopListingAPIGetFeaturedListingsByShopRequest) Limit(limit int64) ShopListingAPIGetFeaturedListingsByShopRequest {
	r.limit = &limit
	return r
}

// The number of records to skip before selecting the first result.
func (r ShopListingAPIGetFeaturedListingsByShopRequest) Offset(offset int64) ShopListingAPIGetFeaturedListingsByShopRequest {
	r.offset = &offset
	return r
}

func (r ShopListingAPIGetFeaturedListingsByShopRequest) Execute() (*ShopListings, *http.Response, error) {
	return r.ApiService.GetFeaturedListingsByShopExecute(r)
}

/*
GetFeaturedListingsByShop Method for GetFeaturedListingsByShop

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notificationPrimary wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Retrieves Listings associated to a Shop that are featured.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shopId The unique positive non-zero numeric ID for an Etsy Shop.
	@return ShopListingAPIGetFeaturedListingsByShopRequest
*/
func (a *ShopListingAPIService) GetFeaturedListingsByShop(ctx context.Context, shopId int64) ShopListingAPIGetFeaturedListingsByShopRequest {
	return ShopListingAPIGetFeaturedListingsByShopRequest{
		ApiService: a,
		ctx:        ctx,
		shopId:     shopId,
	}
}

// Execute executes the request
//
//	@return ShopListings
func (a *ShopListingAPIService) GetFeaturedListingsByShopExecute(r ShopListingAPIGetFeaturedListingsByShopRequest) (*ShopListings, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ShopListings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopListingAPIService.GetFeaturedListingsByShop")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/shops/{shop_id}/listings/featured"
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId < 1 {
		return localVarReturnValue, nil, reportError("shopId must be greater than 1")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int64 = 25
		r.limit = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int64 = 0
		r.offset = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-api-key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ShopListingAPIGetListingRequest struct {
	ctx        context.Context
	ApiService ShopListingAPI
	listingId  int64
	includes   *[]GetListingsByShopIncludesParameterInner
	language   *string
}

// An enumerated string that attaches a valid association. Acceptable inputs are &#39;Shipping&#39;, &#39;Shop&#39;, &#39;Images&#39;, &#39;User&#39;, &#39;Translations&#39; and &#39;Inventory&#39;.
func (r ShopListingAPIGetListingRequest) Includes(includes []GetListingsByShopIncludesParameterInner) ShopListingAPIGetListingRequest {
	r.includes = &includes
	return r
}

// The IETF language tag for the language of this translation. Ex: &#x60;de&#x60;, &#x60;en&#x60;, &#x60;es&#x60;, &#x60;fr&#x60;, &#x60;it&#x60;, &#x60;ja&#x60;, &#x60;nl&#x60;, &#x60;pl&#x60;, &#x60;pt&#x60;.
func (r ShopListingAPIGetListingRequest) Language(language string) ShopListingAPIGetListingRequest {
	r.language = &language
	return r
}

func (r ShopListingAPIGetListingRequest) Execute() (*ShopListingWithAssociations, *http.Response, error) {
	return r.ApiService.GetListingExecute(r)
}

/*
GetListing Method for GetListing

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notificationPrimary wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Retrieves a listing record by listing ID.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listingId The numeric ID for the [listing](/documentation/reference#tag/ShopListing) associated to this transaction.
	@return ShopListingAPIGetListingRequest
*/
func (a *ShopListingAPIService) GetListing(ctx context.Context, listingId int64) ShopListingAPIGetListingRequest {
	return ShopListingAPIGetListingRequest{
		ApiService: a,
		ctx:        ctx,
		listingId:  listingId,
	}
}

// Execute executes the request
//
//	@return ShopListingWithAssociations
func (a *ShopListingAPIService) GetListingExecute(r ShopListingAPIGetListingRequest) (*ShopListingWithAssociations, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ShopListingWithAssociations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopListingAPIService.GetListing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/listings/{listing_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"listing_id"+"}", url.PathEscape(parameterValueToString(r.listingId, "listingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.listingId < 1 {
		return localVarReturnValue, nil, reportError("listingId must be greater than 1")
	}

	if r.includes != nil {
		t := *r.includes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "includes", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "includes", t, "form", "multi")
		}
	}
	if r.language != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "language", r.language, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-api-key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ShopListingAPIGetListingPropertiesRequest struct {
	ctx        context.Context
	ApiService ShopListingAPI
	shopId     int64
	listingId  int64
}

func (r ShopListingAPIGetListingPropertiesRequest) Execute() (*ListingPropertyValues, *http.Response, error) {
	return r.ApiService.GetListingPropertiesExecute(r)
}

/*
GetListingProperties Method for GetListingProperties

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notificationPrimary wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Get a listing's properties

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shopId The unique positive non-zero numeric ID for an Etsy Shop.
	@param listingId The numeric ID for the [listing](/documentation/reference#tag/ShopListing) associated to this transaction.
	@return ShopListingAPIGetListingPropertiesRequest
*/
func (a *ShopListingAPIService) GetListingProperties(ctx context.Context, shopId int64, listingId int64) ShopListingAPIGetListingPropertiesRequest {
	return ShopListingAPIGetListingPropertiesRequest{
		ApiService: a,
		ctx:        ctx,
		shopId:     shopId,
		listingId:  listingId,
	}
}

// Execute executes the request
//
//	@return ListingPropertyValues
func (a *ShopListingAPIService) GetListingPropertiesExecute(r ShopListingAPIGetListingPropertiesRequest) (*ListingPropertyValues, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListingPropertyValues
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopListingAPIService.GetListingProperties")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/shops/{shop_id}/listings/{listing_id}/properties"
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listing_id"+"}", url.PathEscape(parameterValueToString(r.listingId, "listingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId < 1 {
		return localVarReturnValue, nil, reportError("shopId must be greater than 1")
	}
	if r.listingId < 1 {
		return localVarReturnValue, nil, reportError("listingId must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-api-key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ShopListingAPIGetListingPropertyRequest struct {
	ctx        context.Context
	ApiService ShopListingAPI
	listingId  int64
	propertyId int64
}

func (r ShopListingAPIGetListingPropertyRequest) Execute() (*ListingPropertyValue, *http.Response, error) {
	return r.ApiService.GetListingPropertyExecute(r)
}

/*
GetListingProperty Method for GetListingProperty

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notificationTertiary wt-mr-xs-2"> Feedback only </span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Give feedback</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">Development for this endpoint is in progress. It will only return a 501 response.</p></div>

Retrieves a listing's property

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listingId The numeric ID for the [listing](/documentation/reference#tag/ShopListing) associated to this transaction.
	@param propertyId The unique ID of an Etsy [listing property](/documentation/reference#operation/getListingProperties).
	@return ShopListingAPIGetListingPropertyRequest
*/
func (a *ShopListingAPIService) GetListingProperty(ctx context.Context, listingId int64, propertyId int64) ShopListingAPIGetListingPropertyRequest {
	return ShopListingAPIGetListingPropertyRequest{
		ApiService: a,
		ctx:        ctx,
		listingId:  listingId,
		propertyId: propertyId,
	}
}

// Execute executes the request
//
//	@return ListingPropertyValue
func (a *ShopListingAPIService) GetListingPropertyExecute(r ShopListingAPIGetListingPropertyRequest) (*ListingPropertyValue, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListingPropertyValue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopListingAPIService.GetListingProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/listings/{listing_id}/properties/{property_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"listing_id"+"}", url.PathEscape(parameterValueToString(r.listingId, "listingId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property_id"+"}", url.PathEscape(parameterValueToString(r.propertyId, "propertyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.listingId < 1 {
		return localVarReturnValue, nil, reportError("listingId must be greater than 1")
	}
	if r.propertyId < 1 {
		return localVarReturnValue, nil, reportError("propertyId must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-api-key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 501 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ShopListingAPIGetListingsByListingIdsRequest struct {
	ctx        context.Context
	ApiService ShopListingAPI
	listingIds *[]int64
	includes   *[]GetListingsByShopIncludesParameterInner
}

// The list of numeric IDS for the listings in a specific Etsy shop.
func (r ShopListingAPIGetListingsByListingIdsRequest) ListingIds(listingIds []int64) ShopListingAPIGetListingsByListingIdsRequest {
	r.listingIds = &listingIds
	return r
}

// An enumerated string that attaches a valid association. Acceptable inputs are &#39;Shipping&#39;, &#39;Shop&#39;, &#39;Images&#39;, &#39;User&#39;, &#39;Translations&#39; and &#39;Inventory&#39;.
func (r ShopListingAPIGetListingsByListingIdsRequest) Includes(includes []GetListingsByShopIncludesParameterInner) ShopListingAPIGetListingsByListingIdsRequest {
	r.includes = &includes
	return r
}

func (r ShopListingAPIGetListingsByListingIdsRequest) Execute() (*ShopListingsWithAssociations, *http.Response, error) {
	return r.ApiService.GetListingsByListingIdsExecute(r)
}

/*
GetListingsByListingIds Method for GetListingsByListingIds

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notificationPrimary wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Allows to query multiple listing ids at once. Limit 100 ids maximum per query.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ShopListingAPIGetListingsByListingIdsRequest
*/
func (a *ShopListingAPIService) GetListingsByListingIds(ctx context.Context) ShopListingAPIGetListingsByListingIdsRequest {
	return ShopListingAPIGetListingsByListingIdsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ShopListingsWithAssociations
func (a *ShopListingAPIService) GetListingsByListingIdsExecute(r ShopListingAPIGetListingsByListingIdsRequest) (*ShopListingsWithAssociations, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ShopListingsWithAssociations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopListingAPIService.GetListingsByListingIds")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/listings/batch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.listingIds == nil {
		return localVarReturnValue, nil, reportError("listingIds is required and must be specified")
	}

	{
		t := *r.listingIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "listing_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "listing_ids", t, "form", "multi")
		}
	}
	if r.includes != nil {
		t := *r.includes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "includes", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "includes", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-api-key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ShopListingAPIGetListingsByShopRequest struct {
	ctx        context.Context
	ApiService ShopListingAPI
	shopId     int64
	state      *GetListingsByShopStateParameter
	limit      *int64
	offset     *int64
	sortOn     *GetListingsByShopSortOnParameter
	sortOrder  *GetListingsByShopSortOrderParameter
	includes   *[]GetListingsByShopIncludesParameterInner
}

// When _updating_ a listing, this value can be either &#x60;active&#x60; or &#x60;inactive&#x60;. Note: Setting a &#x60;draft&#x60; listing to &#x60;active&#x60; will also publish the listing on etsy.com and requires that the listing have an image set. Setting a &#x60;sold_out&#x60; listing to active will update the quantity to 1 and renew the listing on etsy.com.
func (r ShopListingAPIGetListingsByShopRequest) State(state GetListingsByShopStateParameter) ShopListingAPIGetListingsByShopRequest {
	r.state = &state
	return r
}

// The maximum number of results to return.
func (r ShopListingAPIGetListingsByShopRequest) Limit(limit int64) ShopListingAPIGetListingsByShopRequest {
	r.limit = &limit
	return r
}

// The number of records to skip before selecting the first result.
func (r ShopListingAPIGetListingsByShopRequest) Offset(offset int64) ShopListingAPIGetListingsByShopRequest {
	r.offset = &offset
	return r
}

// The value to sort a search result of listings on. NOTES: a) &#x60;sort_on&#x60; only works when combined with one of the search options (keywords, region, etc.). b) when using &#x60;score&#x60; the returned results will always be in _descending_ order, regardless of the &#x60;sort_order&#x60; parameter.
func (r ShopListingAPIGetListingsByShopRequest) SortOn(sortOn GetListingsByShopSortOnParameter) ShopListingAPIGetListingsByShopRequest {
	r.sortOn = &sortOn
	return r
}

// The ascending(up) or descending(down) order to sort listings by. NOTE: sort_order only works when combined with one of the search options (keywords, region, etc.).
func (r ShopListingAPIGetListingsByShopRequest) SortOrder(sortOrder GetListingsByShopSortOrderParameter) ShopListingAPIGetListingsByShopRequest {
	r.sortOrder = &sortOrder
	return r
}

// An enumerated string that attaches a valid association. Acceptable inputs are &#39;Shipping&#39;, &#39;Shop&#39;, &#39;Images&#39;, &#39;User&#39;, &#39;Translations&#39; and &#39;Inventory&#39;.
func (r ShopListingAPIGetListingsByShopRequest) Includes(includes []GetListingsByShopIncludesParameterInner) ShopListingAPIGetListingsByShopRequest {
	r.includes = &includes
	return r
}

func (r ShopListingAPIGetListingsByShopRequest) Execute() (*ShopListingsWithAssociations, *http.Response, error) {
	return r.ApiService.GetListingsByShopExecute(r)
}

/*
GetListingsByShop Method for GetListingsByShop

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notificationPrimary wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Endpoint to list Listings that belong to a Shop. Listings can be filtered using the 'state' param.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shopId The unique positive non-zero numeric ID for an Etsy Shop.
	@return ShopListingAPIGetListingsByShopRequest
*/
func (a *ShopListingAPIService) GetListingsByShop(ctx context.Context, shopId int64) ShopListingAPIGetListingsByShopRequest {
	return ShopListingAPIGetListingsByShopRequest{
		ApiService: a,
		ctx:        ctx,
		shopId:     shopId,
	}
}

// Execute executes the request
//
//	@return ShopListingsWithAssociations
func (a *ShopListingAPIService) GetListingsByShopExecute(r ShopListingAPIGetListingsByShopRequest) (*ShopListingsWithAssociations, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ShopListingsWithAssociations
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopListingAPIService.GetListingsByShop")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/shops/{shop_id}/listings"
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId < 1 {
		return localVarReturnValue, nil, reportError("shopId must be greater than 1")
	}

	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	} else {
		var defaultValue GetListingsByShopStateParameter = "active"
		r.state = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int64 = 25
		r.limit = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int64 = 0
		r.offset = &defaultValue
	}
	if r.sortOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_on", r.sortOn, "form", "")
	} else {
		var defaultValue GetListingsByShopSortOnParameter = "created"
		r.sortOn = &defaultValue
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_order", r.sortOrder, "form", "")
	} else {
		var defaultValue GetListingsByShopSortOrderParameter = "desc"
		r.sortOrder = &defaultValue
	}
	if r.includes != nil {
		t := *r.includes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "includes", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "includes", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-api-key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ShopListingAPIGetListingsByShopReceiptRequest struct {
	ctx        context.Context
	ApiService ShopListingAPI
	receiptId  int64
	shopId     int64
	limit      *int64
	offset     *int64
}

// The maximum number of results to return.
func (r ShopListingAPIGetListingsByShopReceiptRequest) Limit(limit int64) ShopListingAPIGetListingsByShopReceiptRequest {
	r.limit = &limit
	return r
}

// The number of records to skip before selecting the first result.
func (r ShopListingAPIGetListingsByShopReceiptRequest) Offset(offset int64) ShopListingAPIGetListingsByShopReceiptRequest {
	r.offset = &offset
	return r
}

func (r ShopListingAPIGetListingsByShopReceiptRequest) Execute() (*ShopListings, *http.Response, error) {
	return r.ApiService.GetListingsByShopReceiptExecute(r)
}

/*
GetListingsByShopReceipt Method for GetListingsByShopReceipt

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notificationPrimary wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Gets all listings associated with a receipt.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param receiptId The numeric ID for the [receipt](/documentation/reference#tag/Shop-Receipt) associated to this transaction.
	@param shopId The unique positive non-zero numeric ID for an Etsy Shop.
	@return ShopListingAPIGetListingsByShopReceiptRequest
*/
func (a *ShopListingAPIService) GetListingsByShopReceipt(ctx context.Context, receiptId int64, shopId int64) ShopListingAPIGetListingsByShopReceiptRequest {
	return ShopListingAPIGetListingsByShopReceiptRequest{
		ApiService: a,
		ctx:        ctx,
		receiptId:  receiptId,
		shopId:     shopId,
	}
}

// Execute executes the request
//
//	@return ShopListings
func (a *ShopListingAPIService) GetListingsByShopReceiptExecute(r ShopListingAPIGetListingsByShopReceiptRequest) (*ShopListings, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ShopListings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopListingAPIService.GetListingsByShopReceipt")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/shops/{shop_id}/receipts/{receipt_id}/listings"
	localVarPath = strings.Replace(localVarPath, "{"+"receipt_id"+"}", url.PathEscape(parameterValueToString(r.receiptId, "receiptId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.receiptId < 1 {
		return localVarReturnValue, nil, reportError("receiptId must be greater than 1")
	}
	if r.shopId < 1 {
		return localVarReturnValue, nil, reportError("shopId must be greater than 1")
	}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int64 = 25
		r.limit = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int64 = 0
		r.offset = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-api-key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ShopListingAPIGetListingsByShopReturnPolicyRequest struct {
	ctx            context.Context
	ApiService     ShopListingAPI
	returnPolicyId int64
	shopId         int64
}

func (r ShopListingAPIGetListingsByShopReturnPolicyRequest) Execute() (*ShopListings, *http.Response, error) {
	return r.ApiService.GetListingsByShopReturnPolicyExecute(r)
}

/*
GetListingsByShopReturnPolicy Method for GetListingsByShopReturnPolicy

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notificationPrimary wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Gets all listings associated with a Return Policy.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param returnPolicyId The numeric ID of the [Return Policy](/documentation/reference#operation/getShopReturnPolicies).
	@param shopId The unique positive non-zero numeric ID for an Etsy Shop.
	@return ShopListingAPIGetListingsByShopReturnPolicyRequest
*/
func (a *ShopListingAPIService) GetListingsByShopReturnPolicy(ctx context.Context, returnPolicyId int64, shopId int64) ShopListingAPIGetListingsByShopReturnPolicyRequest {
	return ShopListingAPIGetListingsByShopReturnPolicyRequest{
		ApiService:     a,
		ctx:            ctx,
		returnPolicyId: returnPolicyId,
		shopId:         shopId,
	}
}

// Execute executes the request
//
//	@return ShopListings
func (a *ShopListingAPIService) GetListingsByShopReturnPolicyExecute(r ShopListingAPIGetListingsByShopReturnPolicyRequest) (*ShopListings, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ShopListings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopListingAPIService.GetListingsByShopReturnPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/shops/{shop_id}/policies/return/{return_policy_id}/listings"
	localVarPath = strings.Replace(localVarPath, "{"+"return_policy_id"+"}", url.PathEscape(parameterValueToString(r.returnPolicyId, "returnPolicyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.returnPolicyId < 1 {
		return localVarReturnValue, nil, reportError("returnPolicyId must be greater than 1")
	}
	if r.shopId < 1 {
		return localVarReturnValue, nil, reportError("shopId must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-api-key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ShopListingAPIGetListingsByShopSectionIdRequest struct {
	ctx            context.Context
	ApiService     ShopListingAPI
	shopId         int64
	shopSectionIds *[]int64
	limit          *int64
	offset         *int64
	sortOn         *GetListingsByShopSortOnParameter
	sortOrder      *GetListingsByShopSortOrderParameter
}

// A list of numeric IDS for all sections in a specific Etsy shop.
func (r ShopListingAPIGetListingsByShopSectionIdRequest) ShopSectionIds(shopSectionIds []int64) ShopListingAPIGetListingsByShopSectionIdRequest {
	r.shopSectionIds = &shopSectionIds
	return r
}

// The maximum number of results to return.
func (r ShopListingAPIGetListingsByShopSectionIdRequest) Limit(limit int64) ShopListingAPIGetListingsByShopSectionIdRequest {
	r.limit = &limit
	return r
}

// The number of records to skip before selecting the first result.
func (r ShopListingAPIGetListingsByShopSectionIdRequest) Offset(offset int64) ShopListingAPIGetListingsByShopSectionIdRequest {
	r.offset = &offset
	return r
}

// The value to sort a search result of listings on. NOTES: a) &#x60;sort_on&#x60; only works when combined with one of the search options (keywords, region, etc.). b) when using &#x60;score&#x60; the returned results will always be in _descending_ order, regardless of the &#x60;sort_order&#x60; parameter.
func (r ShopListingAPIGetListingsByShopSectionIdRequest) SortOn(sortOn GetListingsByShopSortOnParameter) ShopListingAPIGetListingsByShopSectionIdRequest {
	r.sortOn = &sortOn
	return r
}

// The ascending(up) or descending(down) order to sort listings by. NOTE: sort_order only works when combined with one of the search options (keywords, region, etc.).
func (r ShopListingAPIGetListingsByShopSectionIdRequest) SortOrder(sortOrder GetListingsByShopSortOrderParameter) ShopListingAPIGetListingsByShopSectionIdRequest {
	r.sortOrder = &sortOrder
	return r
}

func (r ShopListingAPIGetListingsByShopSectionIdRequest) Execute() (*ShopListings, *http.Response, error) {
	return r.ApiService.GetListingsByShopSectionIdExecute(r)
}

/*
GetListingsByShopSectionId Method for GetListingsByShopSectionId

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notificationPrimary wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Retrieves all the listings from the section of a specific shop.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shopId The unique positive non-zero numeric ID for an Etsy Shop.
	@return ShopListingAPIGetListingsByShopSectionIdRequest
*/
func (a *ShopListingAPIService) GetListingsByShopSectionId(ctx context.Context, shopId int64) ShopListingAPIGetListingsByShopSectionIdRequest {
	return ShopListingAPIGetListingsByShopSectionIdRequest{
		ApiService: a,
		ctx:        ctx,
		shopId:     shopId,
	}
}

// Execute executes the request
//
//	@return ShopListings
func (a *ShopListingAPIService) GetListingsByShopSectionIdExecute(r ShopListingAPIGetListingsByShopSectionIdRequest) (*ShopListings, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ShopListings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopListingAPIService.GetListingsByShopSectionId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/shops/{shop_id}/shop-sections/listings"
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId < 1 {
		return localVarReturnValue, nil, reportError("shopId must be greater than 1")
	}
	if r.shopSectionIds == nil {
		return localVarReturnValue, nil, reportError("shopSectionIds is required and must be specified")
	}

	{
		t := *r.shopSectionIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "shop_section_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "shop_section_ids", t, "form", "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int64 = 25
		r.limit = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int64 = 0
		r.offset = &defaultValue
	}
	if r.sortOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_on", r.sortOn, "form", "")
	} else {
		var defaultValue GetListingsByShopSortOnParameter = "created"
		r.sortOn = &defaultValue
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_order", r.sortOrder, "form", "")
	} else {
		var defaultValue GetListingsByShopSortOrderParameter = "desc"
		r.sortOrder = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-api-key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ShopListingAPIUpdateListingRequest struct {
	ctx                         context.Context
	ApiService                  ShopListingAPI
	shopId                      int64
	listingId                   int64
	imageIds                    *[]int64
	title                       *string
	description                 *string
	materials                   *[]string
	shouldAutoRenew             *bool
	shippingProfileId           *int64
	returnPolicyId              *int64
	shopSectionId               *int64
	itemWeight                  *float32
	itemLength                  *float32
	itemWidth                   *float32
	itemHeight                  *float32
	itemWeightUnit              *UpdateListingRequestItemWeightUnit
	itemDimensionsUnit          *UpdateListingRequestItemDimensionsUnit
	isTaxable                   *bool
	taxonomyId                  *int64
	tags                        *[]string
	whoMade                     *CreateDraftListingRequestWhoMade
	whenMade                    *CreateDraftListingRequestWhenMade
	featuredRank                *int64
	isPersonalizable            *bool
	personalizationIsRequired   *bool
	personalizationCharCountMax *int64
	personalizationInstructions *string
	state                       *UpdateListingDeprecatedRequestState
	isSupply                    *bool
	productionPartnerIds        *[]int64
	type_                       *UpdateListingDeprecatedRequestType
}

// An array of numeric image IDs of the images in a listing, which can include up to 10 images.
func (r ShopListingAPIUpdateListingRequest) ImageIds(imageIds []int64) ShopListingAPIUpdateListingRequest {
	r.imageIds = &imageIds
	return r
}

// The listing&#39;s title string. When creating or updating a listing, valid title strings contain only letters, numbers, punctuation marks, mathematical symbols, whitespace characters, ™, ©, and ®. (regex: /[^\\\\p{L}\\\\p{Nd}\\\\p{P}\\\\p{Sm}\\\\p{Zs}™©®]/u) You can only use the %, :, &amp; and + characters once each.
func (r ShopListingAPIUpdateListingRequest) Title(title string) ShopListingAPIUpdateListingRequest {
	r.title = &title
	return r
}

// A description string of the product for sale in the listing.
func (r ShopListingAPIUpdateListingRequest) Description(description string) ShopListingAPIUpdateListingRequest {
	r.description = &description
	return r
}

// A list of material strings for materials used in the product. Valid materials strings contain only letters, numbers, and whitespace characters. (regex: /[^\\\\p{L}\\\\p{Nd}\\\\p{Zs}]/u) Default value is null.
func (r ShopListingAPIUpdateListingRequest) Materials(materials []string) ShopListingAPIUpdateListingRequest {
	r.materials = &materials
	return r
}

// When true, renews a listing for four months upon expiration.
func (r ShopListingAPIUpdateListingRequest) ShouldAutoRenew(shouldAutoRenew bool) ShopListingAPIUpdateListingRequest {
	r.shouldAutoRenew = &shouldAutoRenew
	return r
}

// The numeric ID of the [shipping profile](/documentation/reference#operation/getShopShippingProfile) associated with the listing. Required when listing type is &#x60;physical&#x60;.
func (r ShopListingAPIUpdateListingRequest) ShippingProfileId(shippingProfileId int64) ShopListingAPIUpdateListingRequest {
	r.shippingProfileId = &shippingProfileId
	return r
}

// The numeric ID of the [Return Policy](/documentation/reference#operation/getShopReturnPolicies). Required for active physical listings. This requirement does not apply to listings of EU-based shops.
func (r ShopListingAPIUpdateListingRequest) ReturnPolicyId(returnPolicyId int64) ShopListingAPIUpdateListingRequest {
	r.returnPolicyId = &returnPolicyId
	return r
}

// The numeric ID of the [shop section](/documentation/reference#tag/Shop-Section) for this listing. Default value is null.
func (r ShopListingAPIUpdateListingRequest) ShopSectionId(shopSectionId int64) ShopListingAPIUpdateListingRequest {
	r.shopSectionId = &shopSectionId
	return r
}

// The numeric weight of the product measured in units set in &#39;item_weight_unit&#39;. Default value is null. If set, the value must be greater than 0.
func (r ShopListingAPIUpdateListingRequest) ItemWeight(itemWeight float32) ShopListingAPIUpdateListingRequest {
	r.itemWeight = &itemWeight
	return r
}

// The numeric length of the product measured in units set in &#39;item_dimensions_unit&#39;. Default value is null. If set, the value must be greater than 0.
func (r ShopListingAPIUpdateListingRequest) ItemLength(itemLength float32) ShopListingAPIUpdateListingRequest {
	r.itemLength = &itemLength
	return r
}

// The numeric width of the product measured in units set in &#39;item_dimensions_unit&#39;. Default value is null. If set, the value must be greater than 0.
func (r ShopListingAPIUpdateListingRequest) ItemWidth(itemWidth float32) ShopListingAPIUpdateListingRequest {
	r.itemWidth = &itemWidth
	return r
}

// The numeric height of the product measured in units set in &#39;item_dimensions_unit&#39;. Default value is null. If set, the value must be greater than 0.
func (r ShopListingAPIUpdateListingRequest) ItemHeight(itemHeight float32) ShopListingAPIUpdateListingRequest {
	r.itemHeight = &itemHeight
	return r
}

func (r ShopListingAPIUpdateListingRequest) ItemWeightUnit(itemWeightUnit UpdateListingRequestItemWeightUnit) ShopListingAPIUpdateListingRequest {
	r.itemWeightUnit = &itemWeightUnit
	return r
}

func (r ShopListingAPIUpdateListingRequest) ItemDimensionsUnit(itemDimensionsUnit UpdateListingRequestItemDimensionsUnit) ShopListingAPIUpdateListingRequest {
	r.itemDimensionsUnit = &itemDimensionsUnit
	return r
}

// When true, applicable [shop](/documentation/reference#tag/Shop) tax rates apply to this listing at checkout.
func (r ShopListingAPIUpdateListingRequest) IsTaxable(isTaxable bool) ShopListingAPIUpdateListingRequest {
	r.isTaxable = &isTaxable
	return r
}

// The numerical taxonomy ID of the listing. See [SellerTaxonomy](/documentation/reference#tag/SellerTaxonomy) and [BuyerTaxonomy](/documentation/reference#tag/BuyerTaxonomy) for more information.
func (r ShopListingAPIUpdateListingRequest) TaxonomyId(taxonomyId int64) ShopListingAPIUpdateListingRequest {
	r.taxonomyId = &taxonomyId
	return r
}

// A comma-separated list of tag strings for the listing. When creating or updating a listing, valid tag strings contain only letters, numbers, whitespace characters, -, &#39;, ™, ©, and ®. (regex: /[^\\\\p{L}\\\\p{Nd}\\\\p{Zs}\\\\-&#39;™©®]/u) Default value is null.
func (r ShopListingAPIUpdateListingRequest) Tags(tags []string) ShopListingAPIUpdateListingRequest {
	r.tags = &tags
	return r
}

func (r ShopListingAPIUpdateListingRequest) WhoMade(whoMade CreateDraftListingRequestWhoMade) ShopListingAPIUpdateListingRequest {
	r.whoMade = &whoMade
	return r
}

func (r ShopListingAPIUpdateListingRequest) WhenMade(whenMade CreateDraftListingRequestWhenMade) ShopListingAPIUpdateListingRequest {
	r.whenMade = &whenMade
	return r
}

// The positive non-zero numeric position in the featured listings of the shop, with rank 1 listings appearing in the left-most position in featured listing on a shop’s home page.
func (r ShopListingAPIUpdateListingRequest) FeaturedRank(featuredRank int64) ShopListingAPIUpdateListingRequest {
	r.featuredRank = &featuredRank
	return r
}

// When true, this listing is personalizable. The default value is null.
func (r ShopListingAPIUpdateListingRequest) IsPersonalizable(isPersonalizable bool) ShopListingAPIUpdateListingRequest {
	r.isPersonalizable = &isPersonalizable
	return r
}

// When true, this listing requires personalization. The default value is null. Will only change if is_personalizable is &#39;true&#39;.
func (r ShopListingAPIUpdateListingRequest) PersonalizationIsRequired(personalizationIsRequired bool) ShopListingAPIUpdateListingRequest {
	r.personalizationIsRequired = &personalizationIsRequired
	return r
}

// This is an integer value representing the maximum length for the personalization message entered by the buyer. Will only change if is_personalizable is &#39;true&#39;.
func (r ShopListingAPIUpdateListingRequest) PersonalizationCharCountMax(personalizationCharCountMax int64) ShopListingAPIUpdateListingRequest {
	r.personalizationCharCountMax = &personalizationCharCountMax
	return r
}

// A string representing instructions for the buyer to enter the personalization. Will only change if is_personalizable is &#39;true&#39;.
func (r ShopListingAPIUpdateListingRequest) PersonalizationInstructions(personalizationInstructions string) ShopListingAPIUpdateListingRequest {
	r.personalizationInstructions = &personalizationInstructions
	return r
}

func (r ShopListingAPIUpdateListingRequest) State(state UpdateListingDeprecatedRequestState) ShopListingAPIUpdateListingRequest {
	r.state = &state
	return r
}

// When true, tags the listing as a supply product, else indicates that it&#39;s a finished product. Helps buyers locate the listing under the Supplies heading. Requires &#39;who_made&#39; and &#39;when_made&#39;.
func (r ShopListingAPIUpdateListingRequest) IsSupply(isSupply bool) ShopListingAPIUpdateListingRequest {
	r.isSupply = &isSupply
	return r
}

// An array of unique IDs of production partner ids.
func (r ShopListingAPIUpdateListingRequest) ProductionPartnerIds(productionPartnerIds []int64) ShopListingAPIUpdateListingRequest {
	r.productionPartnerIds = &productionPartnerIds
	return r
}

func (r ShopListingAPIUpdateListingRequest) Type_(type_ UpdateListingDeprecatedRequestType) ShopListingAPIUpdateListingRequest {
	r.type_ = &type_
	return r
}

func (r ShopListingAPIUpdateListingRequest) Execute() (*ShopListing, *http.Response, error) {
	return r.ApiService.UpdateListingExecute(r)
}

/*
UpdateListing Method for UpdateListing

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notificationPrimary wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Updates a listing, identified by a listing ID, for a specific shop identified by a shop ID. Note that this is a PATCH method type. When activating, or manually renewing a physical listing, the shipping profile referenced by the `shipping_profile_id`, and all of its fields, along with its entries and upgrades must be complete and valid. If the shipping profile is not complete and valid, we will throw an exception with an error message that guides the request sender to update whatever data is bad.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shopId The unique positive non-zero numeric ID for an Etsy Shop.
	@param listingId The numeric ID for the [listing](/documentation/reference#tag/ShopListing) associated to this transaction.
	@return ShopListingAPIUpdateListingRequest
*/
func (a *ShopListingAPIService) UpdateListing(ctx context.Context, shopId int64, listingId int64) ShopListingAPIUpdateListingRequest {
	return ShopListingAPIUpdateListingRequest{
		ApiService: a,
		ctx:        ctx,
		shopId:     shopId,
		listingId:  listingId,
	}
}

// Execute executes the request
//
//	@return ShopListing
func (a *ShopListingAPIService) UpdateListingExecute(r ShopListingAPIUpdateListingRequest) (*ShopListing, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ShopListing
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopListingAPIService.UpdateListing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/shops/{shop_id}/listings/{listing_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listing_id"+"}", url.PathEscape(parameterValueToString(r.listingId, "listingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId < 1 {
		return localVarReturnValue, nil, reportError("shopId must be greater than 1")
	}
	if r.listingId < 1 {
		return localVarReturnValue, nil, reportError("listingId must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.imageIds != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "image_ids", r.imageIds, "", "csv")
	}
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "title", r.title, "", "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "description", r.description, "", "")
	}
	if r.materials != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "materials", r.materials, "", "csv")
	}
	if r.shouldAutoRenew != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "should_auto_renew", r.shouldAutoRenew, "", "")
	}
	if r.shippingProfileId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "shipping_profile_id", r.shippingProfileId, "", "")
	}
	if r.returnPolicyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "return_policy_id", r.returnPolicyId, "", "")
	}
	if r.shopSectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "shop_section_id", r.shopSectionId, "", "")
	}
	if r.itemWeight != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "item_weight", r.itemWeight, "", "")
	}
	if r.itemLength != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "item_length", r.itemLength, "", "")
	}
	if r.itemWidth != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "item_width", r.itemWidth, "", "")
	}
	if r.itemHeight != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "item_height", r.itemHeight, "", "")
	}
	if r.itemWeightUnit != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "item_weight_unit", r.itemWeightUnit, "", "")
	}
	if r.itemDimensionsUnit != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "item_dimensions_unit", r.itemDimensionsUnit, "", "")
	}
	if r.isTaxable != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_taxable", r.isTaxable, "", "")
	}
	if r.taxonomyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "taxonomy_id", r.taxonomyId, "", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "tags", r.tags, "", "csv")
	}
	if r.whoMade != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "who_made", r.whoMade, "", "")
	}
	if r.whenMade != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "when_made", r.whenMade, "", "")
	}
	if r.featuredRank != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "featured_rank", r.featuredRank, "", "")
	}
	if r.isPersonalizable != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_personalizable", r.isPersonalizable, "", "")
	}
	if r.personalizationIsRequired != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "personalization_is_required", r.personalizationIsRequired, "", "")
	}
	if r.personalizationCharCountMax != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "personalization_char_count_max", r.personalizationCharCountMax, "", "")
	}
	if r.personalizationInstructions != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "personalization_instructions", r.personalizationInstructions, "", "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "state", r.state, "", "")
	}
	if r.isSupply != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_supply", r.isSupply, "", "")
	}
	if r.productionPartnerIds != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "production_partner_ids", r.productionPartnerIds, "", "csv")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-api-key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ShopListingAPIUpdateListingDeprecatedRequest struct {
	ctx                         context.Context
	ApiService                  ShopListingAPI
	shopId                      int64
	listingId                   int64
	imageIds                    *[]int64
	title                       *string
	description                 *string
	materials                   *[]string
	shouldAutoRenew             *bool
	shippingProfileId           *int64
	shopSectionId               *int64
	itemWeight                  *float32
	itemLength                  *float32
	itemWidth                   *float32
	itemHeight                  *float32
	itemWeightUnit              *CreateDraftListingRequestItemWeightUnit
	itemDimensionsUnit          *CreateDraftListingRequestItemDimensionsUnit
	isTaxable                   *bool
	taxonomyId                  *int64
	tags                        *[]string
	whoMade                     *CreateDraftListingRequestWhoMade
	whenMade                    *CreateDraftListingRequestWhenMade
	featuredRank                *int64
	isPersonalizable            *bool
	personalizationIsRequired   *bool
	personalizationCharCountMax *int64
	personalizationInstructions *string
	state                       *UpdateListingDeprecatedRequestState
	isSupply                    *bool
	productionPartnerIds        *[]int64
	type_                       *UpdateListingDeprecatedRequestType
}

// An array of numeric image IDs of the images in a listing, which can include up to 10 images.
func (r ShopListingAPIUpdateListingDeprecatedRequest) ImageIds(imageIds []int64) ShopListingAPIUpdateListingDeprecatedRequest {
	r.imageIds = &imageIds
	return r
}

// The listing&#39;s title string. When creating or updating a listing, valid title strings contain only letters, numbers, punctuation marks, mathematical symbols, whitespace characters, ™, ©, and ®. (regex: /[^\\\\p{L}\\\\p{Nd}\\\\p{P}\\\\p{Sm}\\\\p{Zs}™©®]/u) You can only use the %, :, &amp; and + characters once each.
func (r ShopListingAPIUpdateListingDeprecatedRequest) Title(title string) ShopListingAPIUpdateListingDeprecatedRequest {
	r.title = &title
	return r
}

// A description string of the product for sale in the listing.
func (r ShopListingAPIUpdateListingDeprecatedRequest) Description(description string) ShopListingAPIUpdateListingDeprecatedRequest {
	r.description = &description
	return r
}

// A list of material strings for materials used in the product. Valid materials strings contain only letters, numbers, and whitespace characters. (regex: /[^\\\\p{L}\\\\p{Nd}\\\\p{Zs}]/u) Default value is null.
func (r ShopListingAPIUpdateListingDeprecatedRequest) Materials(materials []string) ShopListingAPIUpdateListingDeprecatedRequest {
	r.materials = &materials
	return r
}

// When true, renews a listing for four months upon expiration.
func (r ShopListingAPIUpdateListingDeprecatedRequest) ShouldAutoRenew(shouldAutoRenew bool) ShopListingAPIUpdateListingDeprecatedRequest {
	r.shouldAutoRenew = &shouldAutoRenew
	return r
}

// The numeric ID of the [shipping profile](/documentation/reference#operation/getShopShippingProfile) associated with the listing. Required when listing type is &#x60;physical&#x60;.
func (r ShopListingAPIUpdateListingDeprecatedRequest) ShippingProfileId(shippingProfileId int64) ShopListingAPIUpdateListingDeprecatedRequest {
	r.shippingProfileId = &shippingProfileId
	return r
}

// The numeric ID of the [shop section](/documentation/reference#tag/Shop-Section) for this listing. Default value is null.
func (r ShopListingAPIUpdateListingDeprecatedRequest) ShopSectionId(shopSectionId int64) ShopListingAPIUpdateListingDeprecatedRequest {
	r.shopSectionId = &shopSectionId
	return r
}

// The numeric weight of the product measured in units set in &#39;item_weight_unit&#39;. Default value is null. If set, the value must be greater than 0.
func (r ShopListingAPIUpdateListingDeprecatedRequest) ItemWeight(itemWeight float32) ShopListingAPIUpdateListingDeprecatedRequest {
	r.itemWeight = &itemWeight
	return r
}

// The numeric length of the product measured in units set in &#39;item_dimensions_unit&#39;. Default value is null. If set, the value must be greater than 0.
func (r ShopListingAPIUpdateListingDeprecatedRequest) ItemLength(itemLength float32) ShopListingAPIUpdateListingDeprecatedRequest {
	r.itemLength = &itemLength
	return r
}

// The numeric width of the product measured in units set in &#39;item_dimensions_unit&#39;. Default value is null. If set, the value must be greater than 0.
func (r ShopListingAPIUpdateListingDeprecatedRequest) ItemWidth(itemWidth float32) ShopListingAPIUpdateListingDeprecatedRequest {
	r.itemWidth = &itemWidth
	return r
}

// The numeric height of the product measured in units set in &#39;item_dimensions_unit&#39;. Default value is null. If set, the value must be greater than 0.
func (r ShopListingAPIUpdateListingDeprecatedRequest) ItemHeight(itemHeight float32) ShopListingAPIUpdateListingDeprecatedRequest {
	r.itemHeight = &itemHeight
	return r
}

func (r ShopListingAPIUpdateListingDeprecatedRequest) ItemWeightUnit(itemWeightUnit CreateDraftListingRequestItemWeightUnit) ShopListingAPIUpdateListingDeprecatedRequest {
	r.itemWeightUnit = &itemWeightUnit
	return r
}

func (r ShopListingAPIUpdateListingDeprecatedRequest) ItemDimensionsUnit(itemDimensionsUnit CreateDraftListingRequestItemDimensionsUnit) ShopListingAPIUpdateListingDeprecatedRequest {
	r.itemDimensionsUnit = &itemDimensionsUnit
	return r
}

// When true, applicable [shop](/documentation/reference#tag/Shop) tax rates apply to this listing at checkout.
func (r ShopListingAPIUpdateListingDeprecatedRequest) IsTaxable(isTaxable bool) ShopListingAPIUpdateListingDeprecatedRequest {
	r.isTaxable = &isTaxable
	return r
}

// The numerical taxonomy ID of the listing. See [SellerTaxonomy](/documentation/reference#tag/SellerTaxonomy) and [BuyerTaxonomy](/documentation/reference#tag/BuyerTaxonomy) for more information.
func (r ShopListingAPIUpdateListingDeprecatedRequest) TaxonomyId(taxonomyId int64) ShopListingAPIUpdateListingDeprecatedRequest {
	r.taxonomyId = &taxonomyId
	return r
}

// A comma-separated list of tag strings for the listing. When creating or updating a listing, valid tag strings contain only letters, numbers, whitespace characters, -, &#39;, ™, ©, and ®. (regex: /[^\\\\p{L}\\\\p{Nd}\\\\p{Zs}\\\\-&#39;™©®]/u) Default value is null.
func (r ShopListingAPIUpdateListingDeprecatedRequest) Tags(tags []string) ShopListingAPIUpdateListingDeprecatedRequest {
	r.tags = &tags
	return r
}

func (r ShopListingAPIUpdateListingDeprecatedRequest) WhoMade(whoMade CreateDraftListingRequestWhoMade) ShopListingAPIUpdateListingDeprecatedRequest {
	r.whoMade = &whoMade
	return r
}

func (r ShopListingAPIUpdateListingDeprecatedRequest) WhenMade(whenMade CreateDraftListingRequestWhenMade) ShopListingAPIUpdateListingDeprecatedRequest {
	r.whenMade = &whenMade
	return r
}

// The positive non-zero numeric position in the featured listings of the shop, with rank 1 listings appearing in the left-most position in featured listing on a shop’s home page.
func (r ShopListingAPIUpdateListingDeprecatedRequest) FeaturedRank(featuredRank int64) ShopListingAPIUpdateListingDeprecatedRequest {
	r.featuredRank = &featuredRank
	return r
}

// When true, this listing is personalizable. The default value is null.
func (r ShopListingAPIUpdateListingDeprecatedRequest) IsPersonalizable(isPersonalizable bool) ShopListingAPIUpdateListingDeprecatedRequest {
	r.isPersonalizable = &isPersonalizable
	return r
}

// When true, this listing requires personalization. The default value is null. Will only change if is_personalizable is &#39;true&#39;.
func (r ShopListingAPIUpdateListingDeprecatedRequest) PersonalizationIsRequired(personalizationIsRequired bool) ShopListingAPIUpdateListingDeprecatedRequest {
	r.personalizationIsRequired = &personalizationIsRequired
	return r
}

// This is an integer value representing the maximum length for the personalization message entered by the buyer. Will only change if is_personalizable is &#39;true&#39;.
func (r ShopListingAPIUpdateListingDeprecatedRequest) PersonalizationCharCountMax(personalizationCharCountMax int64) ShopListingAPIUpdateListingDeprecatedRequest {
	r.personalizationCharCountMax = &personalizationCharCountMax
	return r
}

// A string representing instructions for the buyer to enter the personalization. Will only change if is_personalizable is &#39;true&#39;.
func (r ShopListingAPIUpdateListingDeprecatedRequest) PersonalizationInstructions(personalizationInstructions string) ShopListingAPIUpdateListingDeprecatedRequest {
	r.personalizationInstructions = &personalizationInstructions
	return r
}

func (r ShopListingAPIUpdateListingDeprecatedRequest) State(state UpdateListingDeprecatedRequestState) ShopListingAPIUpdateListingDeprecatedRequest {
	r.state = &state
	return r
}

// When true, tags the listing as a supply product, else indicates that it&#39;s a finished product. Helps buyers locate the listing under the Supplies heading. Requires &#39;who_made&#39; and &#39;when_made&#39;.
func (r ShopListingAPIUpdateListingDeprecatedRequest) IsSupply(isSupply bool) ShopListingAPIUpdateListingDeprecatedRequest {
	r.isSupply = &isSupply
	return r
}

// An array of unique IDs of production partner ids.
func (r ShopListingAPIUpdateListingDeprecatedRequest) ProductionPartnerIds(productionPartnerIds []int64) ShopListingAPIUpdateListingDeprecatedRequest {
	r.productionPartnerIds = &productionPartnerIds
	return r
}

func (r ShopListingAPIUpdateListingDeprecatedRequest) Type_(type_ UpdateListingDeprecatedRequestType) ShopListingAPIUpdateListingDeprecatedRequest {
	r.type_ = &type_
	return r
}

func (r ShopListingAPIUpdateListingDeprecatedRequest) Execute() (*ShopListing, *http.Response, error) {
	return r.ApiService.UpdateListingDeprecatedExecute(r)
}

/*
UpdateListingDeprecated Method for UpdateListingDeprecated

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notificationPrimary wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Updates a listing, identified by a listing ID, for a specific shop identified by a shop ID. This endpoint will be removed in the near future in favor of `updateListing` PATCH version.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shopId The unique positive non-zero numeric ID for an Etsy Shop.
	@param listingId The numeric ID for the [listing](/documentation/reference#tag/ShopListing) associated to this transaction.
	@return ShopListingAPIUpdateListingDeprecatedRequest
*/
func (a *ShopListingAPIService) UpdateListingDeprecated(ctx context.Context, shopId int64, listingId int64) ShopListingAPIUpdateListingDeprecatedRequest {
	return ShopListingAPIUpdateListingDeprecatedRequest{
		ApiService: a,
		ctx:        ctx,
		shopId:     shopId,
		listingId:  listingId,
	}
}

// Execute executes the request
//
//	@return ShopListing
func (a *ShopListingAPIService) UpdateListingDeprecatedExecute(r ShopListingAPIUpdateListingDeprecatedRequest) (*ShopListing, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ShopListing
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopListingAPIService.UpdateListingDeprecated")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/shops/{shop_id}/listings/{listing_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listing_id"+"}", url.PathEscape(parameterValueToString(r.listingId, "listingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId < 1 {
		return localVarReturnValue, nil, reportError("shopId must be greater than 1")
	}
	if r.listingId < 1 {
		return localVarReturnValue, nil, reportError("listingId must be greater than 1")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.imageIds != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "image_ids", r.imageIds, "", "csv")
	}
	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "title", r.title, "", "")
	}
	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "description", r.description, "", "")
	}
	if r.materials != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "materials", r.materials, "", "csv")
	}
	if r.shouldAutoRenew != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "should_auto_renew", r.shouldAutoRenew, "", "")
	}
	if r.shippingProfileId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "shipping_profile_id", r.shippingProfileId, "", "")
	}
	if r.shopSectionId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "shop_section_id", r.shopSectionId, "", "")
	}
	if r.itemWeight != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "item_weight", r.itemWeight, "", "")
	}
	if r.itemLength != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "item_length", r.itemLength, "", "")
	}
	if r.itemWidth != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "item_width", r.itemWidth, "", "")
	}
	if r.itemHeight != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "item_height", r.itemHeight, "", "")
	}
	if r.itemWeightUnit != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "item_weight_unit", r.itemWeightUnit, "", "")
	}
	if r.itemDimensionsUnit != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "item_dimensions_unit", r.itemDimensionsUnit, "", "")
	}
	if r.isTaxable != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_taxable", r.isTaxable, "", "")
	}
	if r.taxonomyId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "taxonomy_id", r.taxonomyId, "", "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "tags", r.tags, "", "csv")
	}
	if r.whoMade != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "who_made", r.whoMade, "", "")
	}
	if r.whenMade != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "when_made", r.whenMade, "", "")
	}
	if r.featuredRank != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "featured_rank", r.featuredRank, "", "")
	}
	if r.isPersonalizable != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_personalizable", r.isPersonalizable, "", "")
	}
	if r.personalizationIsRequired != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "personalization_is_required", r.personalizationIsRequired, "", "")
	}
	if r.personalizationCharCountMax != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "personalization_char_count_max", r.personalizationCharCountMax, "", "")
	}
	if r.personalizationInstructions != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "personalization_instructions", r.personalizationInstructions, "", "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "state", r.state, "", "")
	}
	if r.isSupply != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "is_supply", r.isSupply, "", "")
	}
	if r.productionPartnerIds != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "production_partner_ids", r.productionPartnerIds, "", "csv")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "type", r.type_, "", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-api-key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ShopListingAPIUpdateListingPropertyRequest struct {
	ctx        context.Context
	ApiService ShopListingAPI
	shopId     int64
	listingId  int64
	propertyId int64
	valueIds   *[]int64
	values     *[]string
	scaleId    *int64
}

// An array of unique IDs of multiple Etsy [listing property](/documentation/reference#operation/getListingProperties) values. For example, if your listing offers different sizes of a product, then the value ID list contains value IDs for each size.
func (r ShopListingAPIUpdateListingPropertyRequest) ValueIds(valueIds []int64) ShopListingAPIUpdateListingPropertyRequest {
	r.valueIds = &valueIds
	return r
}

// An array of value strings for multiple Etsy [listing property](/documentation/reference#operation/getListingProperties) values. For example, if your listing offers different colored products, then the values array contains the color strings for each color. Note: parenthesis characters (&#x60;(&#x60; and &#x60;)&#x60;) are not allowed.
func (r ShopListingAPIUpdateListingPropertyRequest) Values(values []string) ShopListingAPIUpdateListingPropertyRequest {
	r.values = &values
	return r
}

// The numeric ID of a single Etsy.com measurement scale. For example, for shoe size, there are three &#x60;scale_id&#x60;s available - &#x60;UK&#x60;, &#x60;US/Canada&#x60;, and &#x60;EU&#x60;, where &#x60;US/Canada&#x60; has &#x60;scale_id&#x60; 19.
func (r ShopListingAPIUpdateListingPropertyRequest) ScaleId(scaleId int64) ShopListingAPIUpdateListingPropertyRequest {
	r.scaleId = &scaleId
	return r
}

func (r ShopListingAPIUpdateListingPropertyRequest) Execute() (*ListingPropertyValue, *http.Response, error) {
	return r.ApiService.UpdateListingPropertyExecute(r)
}

/*
UpdateListingProperty Method for UpdateListingProperty

<div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><span class="wt-badge wt-badge--notificationPrimary wt-bg-slime-tint wt-mr-xs-2">General Release</span><a class="wt-text-link" href="https://github.com/etsy/open-api/discussions" target="_blank" rel="noopener noreferrer">Report bug</a></div><div class="wt-display-flex-xs wt-align-items-center wt-mt-xs-2 wt-mb-xs-3"><p class="wt-text-body-01 banner-text">This endpoint is ready for production use.</p></div>

Updates or populates the properties list defining product offerings for a listing. Each offering requires both a `value` and a `value_id` that are valid for a `scale_id` assigned to the listing or that you assign to the listing with this request.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shopId The unique positive non-zero numeric ID for an Etsy Shop.
	@param listingId The numeric ID for the [listing](/documentation/reference#tag/ShopListing) associated to this transaction.
	@param propertyId The unique ID of an Etsy [listing property](/documentation/reference#operation/getListingProperties).
	@return ShopListingAPIUpdateListingPropertyRequest
*/
func (a *ShopListingAPIService) UpdateListingProperty(ctx context.Context, shopId int64, listingId int64, propertyId int64) ShopListingAPIUpdateListingPropertyRequest {
	return ShopListingAPIUpdateListingPropertyRequest{
		ApiService: a,
		ctx:        ctx,
		shopId:     shopId,
		listingId:  listingId,
		propertyId: propertyId,
	}
}

// Execute executes the request
//
//	@return ListingPropertyValue
func (a *ShopListingAPIService) UpdateListingPropertyExecute(r ShopListingAPIUpdateListingPropertyRequest) (*ListingPropertyValue, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListingPropertyValue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShopListingAPIService.UpdateListingProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v3/application/shops/{shop_id}/listings/{listing_id}/properties/{property_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"shop_id"+"}", url.PathEscape(parameterValueToString(r.shopId, "shopId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listing_id"+"}", url.PathEscape(parameterValueToString(r.listingId, "listingId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"property_id"+"}", url.PathEscape(parameterValueToString(r.propertyId, "propertyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.shopId < 1 {
		return localVarReturnValue, nil, reportError("shopId must be greater than 1")
	}
	if r.listingId < 1 {
		return localVarReturnValue, nil, reportError("listingId must be greater than 1")
	}
	if r.propertyId < 1 {
		return localVarReturnValue, nil, reportError("propertyId must be greater than 1")
	}
	if r.valueIds == nil {
		return localVarReturnValue, nil, reportError("valueIds is required and must be specified")
	}
	if r.values == nil {
		return localVarReturnValue, nil, reportError("values is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "value_ids", r.valueIds, "", "csv")
	parameterAddToHeaderOrQuery(localVarFormParams, "values", r.values, "", "csv")
	if r.scaleId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "scale_id", r.scaleId, "", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-api-key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-api-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorSchema
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
